<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Simulador SPY (Sintético, Sin Librerías Externas)</title>
  <style>
    :root {
      --bg: #0f1318;
      --panel: #151b22;
      --accent: #2a7de1;
      --accent-2: #3bb273;
      --accent-3: #db504a;
      --text: #e6edf3;
      --muted: #9aa6b2;
      --border: #243140;
      --warn: #ffcc00;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body { margin: 0; background: var(--bg); color: var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, 'Helvetica Neue', Arial, 'Noto Sans', sans-serif; }
    header { padding: 10px 16px; border-bottom: 1px solid var(--border); display: flex; align-items: center; justify-content: space-between; gap: 12px; background: #0d1117; }
    header .title { font-weight: 600; }
    header .badge { font-size: 12px; color: var(--warn); background: #2a2a10; padding: 4px 8px; border-radius: 6px; border: 1px solid #403d14; }
    .layout { display: flex; flex-direction: row; height: calc(100% - 52px); }
    .sidebar { width: 360px; min-width: 280px; max-width: 420px; border-right: 1px solid var(--border); background: var(--panel); padding: 14px; display: flex; flex-direction: column; gap: 12px; }
    .section { border: 1px solid var(--border); border-radius: 10px; padding: 10px; background: #0f141b; }
    .section h3 { margin: 0 0 8px 0; font-size: 14px; color: var(--muted); text-transform: uppercase; letter-spacing: 0.08em; }
    .row { display: flex; gap: 8px; align-items: center; }
    .row.wrap { flex-wrap: wrap; }
    label { font-size: 13px; color: var(--muted); }
    input[type="number"], input[type="text"] { width: 100%; padding: 8px 10px; border-radius: 8px; border: 1px solid var(--border); background: #0c1116; color: var(--text); outline: none; }
    .btn { padding: 8px 12px; border-radius: 8px; border: 1px solid var(--border); background: #0c1116; color: var(--text); cursor: pointer; font-weight: 600; }
    .btn:hover { background: #0e141a; }
    .btn:disabled { opacity: 0.6; cursor: not-allowed; }
    .btn.primary { background: #0b2440; border-color: #14365f; }
    .btn.buy { background: #0f2f22; border-color: #164735; color: #aaf3c9; }
    .btn.sell { background: #2b1717; border-color: #4a2323; color: #f3b2aa; }
    .btn.warn { background: #33290f; border-color: #705a17; color: #ffd978; }
    .metric { display: flex; justify-content: space-between; align-items: baseline; padding: 6px 0; border-bottom: 1px dashed #1e2731; }
    .metric:last-child { border-bottom: none; }
    .metric .label { color: var(--muted); font-size: 12px; }
    .metric .value { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace; }
    .chart-area { flex: 1; display: flex; flex-direction: column; min-width: 0; }
    #chartWrap { flex: 1; position: relative; }
    #chartCanvas { width: 100%; height: 100%; display: block; }
    .tooltip { position: absolute; pointer-events: none; background: rgba(13,17,23,0.92); border: 1px solid var(--border); color: var(--text); padding: 8px 10px; border-radius: 8px; font-size: 12px; display: none; z-index: 10; white-space: nowrap; }
    .tooltip .idx { color: var(--muted); }
    .toasts { position: fixed; right: 16px; bottom: 16px; display: flex; flex-direction: column; gap: 8px; z-index: 1000; }
    .toast { background: #0f141b; border: 1px solid var(--border); color: var(--text); padding: 10px 12px; border-radius: 10px; min-width: 240px; box-shadow: 0 8px 24px rgba(0,0,0,0.35); opacity: 0.97; }
    .toast.success { border-color: #1f513c; }
    .toast.error { border-color: #613032; }
    .toast.info { border-color: #2f4f77; }
  </style>
</head>
<body>
  <header>
    <div class="title">Simulador de Compra/Venta — Activo tipo SPY (FICTICIO)</div>
    <div class="badge">Sin librerías externas — Datos 100% sintéticos</div>
  </header>

  <div class="layout">
    <aside class="sidebar">
      <div class="section">
        <h3>Parámetros del dataset (GBM)</h3>
        <div class="row wrap">
          <div style="flex:1; min-width: 120px;">
            <label for="seed">Semilla</label>
            <input type="number" id="seed" placeholder="p.ej. 12345" />
          </div>
          <div style="flex:1; min-width: 120px;">
            <label for="mu">mu anual</label>
            <input type="number" id="mu" step="0.001" placeholder="0.06" />
          </div>
          <div style="flex:1; min-width: 120px;">
            <label for="sigma">sigma anual</label>
            <input type="number" id="sigma" step="0.001" placeholder="0.18" />
          </div>
        </div>
        <div class="row">
          <button class="btn primary" id="btnNewData">Nuevo dataset</button>
        </div>
        <small style="color: var(--muted); display:block; margin-top:6px;">Modelo GBM con posibles gaps. S[t+1] = S[t] * exp((μ - 0.5·σ²)·dt + σ·√dt·Z), dt=1/252, μ≈0.06, σ≈0.18, Z~N(0,1).</small>
      </div>

      <div class="section">
        <h3>Trading (solo long)</h3>
        <div class="row">
          <label for="qty">Cantidad (entero)</label>
          <input type="number" id="qty" placeholder="100" min="1" />
        </div>
        <div class="row wrap">
          <button class="btn buy" id="btnBuy">Comprar (B)</button>
          <button class="btn sell" id="btnSell">Vender (S)</button>
          <button class="btn warn" id="btnSellAll">Sell All (X)</button>
        </div>
        <div class="row wrap">
          <button class="btn" id="btnAdvance">Advance (A)</button>
          <button class="btn" id="btnNext">Next (N)</button>
          <button class="btn" id="btnReset">Reset</button>
        </div>
        <small style="color: var(--muted); display:block;">Ejecución al <b>cierre</b> de la vela visible actual. Comisiones=0, Slippage=0.</small>
      </div>

      <div class="section">
        <h3>Métricas</h3>
        <div class="metric"><span class="label">Capital inicial</span><span class="value" id="mInitial">—</span></div>
        <div class="metric"><span class="label">Cash</span><span class="value" id="mCash">—</span></div>
        <div class="metric"><span class="label">Qty (acciones)</span><span class="value" id="mQty">—</span></div>
        <div class="metric"><span class="label">Costo promedio</span><span class="value" id="mAvg">—</span></div>
        <div class="metric"><span class="label">Valor posición</span><span class="value" id="mPosVal">—</span></div>
        <div class="metric"><span class="label">% posición sobre equity</span><span class="value" id="mPosPct">—</span></div>
        <div class="metric"><span class="label">Unrealized</span><span class="value" id="mUnreal">—</span></div>
        <div class="metric"><span class="label">Realized</span><span class="value" id="mRealized">—</span></div>
        <div class="metric"><span class="label">Equity</span><span class="value" id="mEquity">—</span></div>
        <div class="metric"><span class="label">Ganancia % vs capital inicial</span><span class="value" id="mGainPct">—</span></div>
        <div class="metric"><span class="label">Escenarios completados</span><span class="value" id="mScenarios">0</span></div>
        <div class="metric"><span class="label">Mejor equity</span><span class="value" id="mBestEquity">—</span></div>
        <div class="metric"><span class="label">Vela actual / 100</span><span class="value" id="mCandleIdx">—</span></div>
      </div>
    </aside>

    <main class="chart-area">
      <div id="chartWrap">
        <canvas id="chartCanvas"></canvas>
        <div id="tooltip" class="tooltip"></div>
      </div>
    </main>
  </div>

  <div class="toasts" id="toasts"></div>

  <script>
    "use strict";
    /**
     * Simulador SPY (Canvas) con ventana deslizante: al pulsar "Advance" con 100 velas visibles,
     * el gráfico AVANZA 1 vela: se toma la siguiente del dataset; si no hay, se GENERA una nueva vela
     * y se desplaza la ventana manteniendo 100.
     */

    const LS_KEY = 'spy_sim_state_canvas_v3';
    const CAPITAL_INICIAL_DEFAULT = 25000;
    const DATA_TOTAL_DEFAULT = 5000;
    const SEGMENT_LENGTH = 100;

    const elCanvas = document.getElementById('chartCanvas');
    const elWrap = document.getElementById('chartWrap');
    const elTooltip = document.getElementById('tooltip');
    const elToasts = document.getElementById('toasts');

    const elSeed = document.getElementById('seed');
    const elMu = document.getElementById('mu');
    const elSigma = document.getElementById('sigma');
    const elQty = document.getElementById('qty');
    const btnNewData = document.getElementById('btnNewData');
    const btnBuy = document.getElementById('btnBuy');
    const btnSell = document.getElementById('btnSell');
    const btnSellAll = document.getElementById('btnSellAll');
    const btnAdvance = document.getElementById('btnAdvance');
    const btnNext = document.getElementById('btnNext');
    const btnReset = document.getElementById('btnReset');

    const mInitial = document.getElementById('mInitial');
    const mCash = document.getElementById('mCash');
    const mQty = document.getElementById('mQty');
    const mAvg = document.getElementById('mAvg');
    const mPosVal = document.getElementById('mPosVal');
    const mPosPct = document.getElementById('mPosPct');
    const mUnreal = document.getElementById('mUnreal');
    const mRealized = document.getElementById('mRealized');
    const mEquity = document.getElementById('mEquity');
    const mGainPct = document.getElementById('mGainPct');
    const mScenarios = document.getElementById('mScenarios');
    const mBestEquity = document.getElementById('mBestEquity');
    const mCandleIdx = document.getElementById('mCandleIdx');

    const state = {
      capitalInicial: CAPITAL_INICIAL_DEFAULT,
      cash: CAPITAL_INICIAL_DEFAULT,
      qty: 0,
      avgCost: null,
      realized: 0,
      equity: CAPITAL_INICIAL_DEFAULT,
      mejorEquity: CAPITAL_INICIAL_DEFAULT,
      escenariosCompletados: 0,
      params: { total: DATA_TOTAL_DEFAULT, seed: Date.now() % 1000000, mu: 0.06, sigma: 0.18 },
      dataset: [],
      ema100: [],
      ema50: [],
      ema35: [],
      currentSegment: [],
      segmentStartIndex: 0, // índice en dataset del primer elemento de la ventana de 100
      currentIndex: SEGMENT_LENGTH - 1, // última vela visible (100)
      dpr: window.devicePixelRatio || 1,
      mouseX: null,
      mouseY: null,
      hoverIndex: null,

      // RNG para generación en vivo (cuando se acaba el dataset)
      lcgSeed: null,
      lcgState: null,
      normalSpare: null,
    };

    const round4 = v => Math.round(v * 10000) / 10000;
    function formatUSD(x){ const n = Number(x || 0); return n.toLocaleString('es-AR',{style:'currency',currency:'USD',maximumFractionDigits:2}); }
    function formatPct(x){ const n = Number(x || 0); return `${n.toFixed(2)}%`; }

    function lcg(){
      // LCG: X_{n+1} = (aX_n + c) mod m, devuelve [0,1)
      const m = 0x100000000, a = 1664525, c = 1013904223;
      if(state.lcgState==null){ state.lcgState = (state.params.seed>>>0) || 123456789; }
      state.lcgState = (a * state.lcgState + c) % m;
      return state.lcgState / m;
    }
    function normal(){
      if(state.normalSpare!=null){ const z=state.normalSpare; state.normalSpare=null; return z; }
      let u=0,v=0; while(u===0) u=lcg(); while(v===0) v=lcg();
      const r=Math.sqrt(-2*Math.log(u)), t=2*Math.PI*v; const z0=r*Math.cos(t), z1=r*Math.sin(t);
      state.normalSpare = z1; return z0;
    }

    function generateSyntheticData(total=DATA_TOTAL_DEFAULT, seed=Date.now()%1000000, mu=0.06, sigma=0.18){
      state.params.seed = seed; state.lcgState = seed>>>0; state.normalSpare = null;
      const dt=1/252, gapProb=0.03, gapStd=0.02; const data=[]; let S=450, prevClose=S;
      for(let t=0;t<total;t++){
        const Z=normal(); const drift=(mu-0.5*sigma*sigma)*dt; const vol=sigma*Math.sqrt(dt)*Z;
        S = prevClose * Math.exp(drift+vol); if(S<=0) S=Math.abs(S)+1;
        let open = prevClose;
        if(lcg()<gapProb){ const gap = normal()*gapStd; open = prevClose*(1+gap); if(open<=0) open=Math.abs(open)+1; }
        const close=S; const r=Math.abs(normal())*0.008; const baseMax=Math.max(open,close); const baseMin=Math.min(open,close);
        let high=baseMax + r*close; let low=baseMin - r*close;
        if(high<baseMax) high=baseMax; if(low>baseMin) low=baseMin; if(low<=0) low=Math.max(0.01,low);
        data.push({ time:t, open:round4(open), high:round4(high), low:round4(low), close:round4(close) });
        prevClose=close;
      }
      return data;
    }

    function computeEMA(data, period){
      const alpha = 2 / (period + 1); const ema = new Array(data.length).fill(null); let prev=null;
      for(let i=0;i<data.length;i++){ const price=data[i].close; prev = (prev==null)? price : (alpha*price + (1-alpha)*prev); ema[i]=prev; }
      return ema;
    }

    function pickRandomSegment(data, length=SEGMENT_LENGTH){
      const maxStart = data.length - length; const start = Math.floor(Math.random()*(maxStart+1));
      const segment = data.slice(start,start+length); return { segment, startIndex:start };
    }

    function resizeCanvas(){ const rect=elWrap.getBoundingClientRect(); const dpr=state.dpr; elCanvas.width=Math.max(1,Math.floor(rect.width*dpr)); elCanvas.height=Math.max(1,Math.floor(rect.height*dpr)); elCanvas.style.width=rect.width+'px'; elCanvas.style.height=rect.height+'px'; }

    function drawPriceScale(ctx, padL, padR, padT, padB, plotW, plotH, minY, maxY){
      const dpr = state.dpr; const ticks = 6; ctx.fillStyle = '#cdd9e5'; ctx.font = `${12*dpr}px system-ui, -apple-system, Segoe UI, Roboto, Arial`; ctx.textAlign = 'left'; ctx.textBaseline = 'middle';
      for(let i=0;i<ticks;i++){ const y = padT + (plotH/(ticks-1))*i; const price = maxY - ( (y - padT) / (plotH) ) * (maxY - minY); const label = `$${price.toFixed(2)}`; ctx.fillStyle = '#9aa6b2'; ctx.fillText(label, (padL - 44*dpr), y); }
      const lastCandle = state.currentSegment[state.currentIndex]; if(lastCandle){ const lastPrice=lastCandle.close; const yScale=plotH/(maxY-minY); const yPix = padT + (maxY - lastPrice)*yScale; const xBox=padL+plotW+4*dpr; const wBox=64*dpr, hBox=18*dpr; ctx.fillStyle='#0f141b'; ctx.fillRect(xBox - wBox - 8*dpr, yPix - hBox/2, wBox, hBox); ctx.strokeStyle='#243140'; ctx.lineWidth=1*dpr; ctx.strokeRect(xBox - wBox - 8*dpr, yPix - hBox/2, wBox, hBox); ctx.fillStyle='#e6edf3'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(`$${lastPrice.toFixed(2)}`, xBox - wBox/2 - 8*dpr, yPix); }
    }

    function drawEMALine(ctx, visible, emaArray, color, padL, padT, plotW, plotH, minY, maxY){
      const dpr=state.dpr, n=visible.length; const gap=Math.max(4*dpr, plotW/Math.max(n,1)); const xOf=(i)=> padL + i*gap + gap*0.5; const yScale=plotH/(maxY-minY); const startIdx=state.segmentStartIndex; ctx.strokeStyle=color; ctx.lineWidth=1.5*dpr; ctx.beginPath();
      for(let i=0;i<n;i++){ const globalIdx=startIdx+i; const v=emaArray[globalIdx]; if(v==null) continue; const x=xOf(i); const y=padT + (maxY - v)*yScale; if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); }
      ctx.stroke(); }

    function drawChart(){
      if(!state.currentSegment.length) return; const ctx = elCanvas.getContext('2d'); const dpr=state.dpr; ctx.setTransform(1,0,0,1,0,0); ctx.clearRect(0,0,elCanvas.width,elCanvas.height); ctx.fillStyle='#0f1318'; ctx.fillRect(0,0,elCanvas.width,elCanvas.height);
      const visible = state.currentSegment.slice(0, state.currentIndex+1); const W=elCanvas.width,H=elCanvas.height; const padL=56*dpr,padR=72*dpr,padT=16*dpr,padB=24*dpr; const plotW=W-padL-padR, plotH=H-padT-padB;
      let minY=Infinity,maxY=-Infinity; for(const c of visible){ if(c.low<minY) minY=c.low; if(c.high>maxY) maxY=c.high; } if(!isFinite(minY)||!isFinite(maxY)||minY>=maxY){ minY=0; maxY=1; }
      const yScale=plotH/(maxY-minY), yToPix=(p)=> (padT + (maxY - p)*yScale);
      const n=visible.length; const gap=Math.max(4*dpr, plotW/Math.max(n,1)); const bodyW=Math.max(3*dpr, gap*0.6); const xOf=(i)=> padL + i*gap + gap*0.5;
      ctx.strokeStyle='#1a232d'; ctx.lineWidth=1*dpr; for(let g=0; g<=4; g++){ const y=padT + (plotH/4)*g; ctx.beginPath(); ctx.moveTo(padL,y); ctx.lineTo(padL+plotW,y); ctx.stroke(); }
      drawEMALine(ctx, visible, state.ema100, '#1e90ff', padL, padT, plotW, plotH, minY, maxY); // azul
      drawEMALine(ctx, visible, state.ema50, '#ffd400', padL, padT, plotW, plotH, minY, maxY);  // amarillo
      drawEMALine(ctx, visible, state.ema35, '#ffffff', padL, padT, plotW, plotH, minY, maxY);  // blanco
      for(let i=0;i<n;i++){ const c=visible[i]; const x=xOf(i); const yOpen=yToPix(c.open), yClose=yToPix(c.close), yHigh=yToPix(c.high), yLow=yToPix(c.low); const up=c.close>=c.open; const bodyTop=Math.min(yOpen,yClose); const bodyH=Math.max(1*dpr, Math.abs(yClose-yOpen)); ctx.strokeStyle= up? '#3bb273' : '#db504a'; ctx.beginPath(); ctx.moveTo(x,yHigh); ctx.lineTo(x,yLow); ctx.stroke(); ctx.fillStyle= up? '#173f2d' : '#3a1f1f'; ctx.fillRect(x-bodyW/2, bodyTop, bodyW, bodyH); ctx.strokeRect(x-bodyW/2, bodyTop, bodyW, bodyH); }
      drawPriceScale(ctx, padL,padR,padT,padB,plotW,plotH,minY,maxY);
      if(state.mouseX!==null && state.mouseY!==null){ const rect=elWrap.getBoundingClientRect(); const mx=state.mouseX-rect.left, my=state.mouseY-rect.top; const mxCanvas=mx*dpr, myCanvas=my*dpr; if(mxCanvas>=padL && mxCanvas<=padL+plotW && myCanvas>=padT && myCanvas<=padT+plotH){ const idx=Math.max(0, Math.min(n-1, Math.floor((mxCanvas-padL)/gap))); state.hoverIndex=idx; const c=visible[idx]; ctx.strokeStyle='#3a5a8a'; ctx.lineWidth=1*dpr; ctx.setLineDash([4*dpr,3*dpr]); const x=xOf(idx); ctx.beginPath(); ctx.moveTo(x,padT); ctx.lineTo(x,padT+plotH); ctx.stroke(); ctx.setLineDash([]); const tip=`Vela #${idx+1}  |  O: $${c.open.toFixed(2)}  H: $${c.high.toFixed(2)}  L: $${c.low.toFixed(2)}  C: $${c.close.toFixed(2)}`; elTooltip.textContent=tip; const tx=Math.min(mx+12, rect.width-220), ty=Math.min(my+12, rect.height-60); elTooltip.style.left=tx+'px'; elTooltip.style.top=ty+'px'; elTooltip.style.display='block'; } else { state.hoverIndex=null; elTooltip.style.display='none'; } } else { elTooltip.style.display='none'; }
    }

    elWrap.addEventListener('mousemove',(ev)=>{ state.mouseX=ev.clientX; state.mouseY=ev.clientY; drawChart(); });
    elWrap.addEventListener('mouseleave',()=>{ state.mouseX=null; state.mouseY=null; state.hoverIndex=null; drawChart(); });

    function renderChart(segment){ resizeCanvas(); drawChart(); }
    function updateChartProgress(){ drawChart(); }

    // ---- Avance deslizante ----
    function advanceOneCandle(){
      if(!state.dataset.length || !state.currentSegment.length){ showToast('No hay datos cargados.', 'error'); return; }
      // ¿hay siguiente vela en el dataset?
      const nextGlobalIdx = state.segmentStartIndex + state.currentIndex + 1; // apunta al elemento después de la última visible
      let nextCandle = null;
      if(nextGlobalIdx < state.dataset.length){
        nextCandle = state.dataset[nextGlobalIdx];
      } else {
        // Generar NUEVA vela en vivo a partir del último cierre
        const last = state.dataset[state.dataset.length-1] || state.currentSegment[state.currentSegment.length-1];
        const dt=1/252, mu=state.params.mu, sigma=state.params.sigma; const Z=normal(); const drift=(mu-0.5*sigma*sigma)*dt; const vol=sigma*Math.sqrt(dt)*Z;
        const prevClose = last.close; let S = prevClose * Math.exp(drift+vol); if(S<=0) S=Math.abs(S)+1;
        let open = prevClose; if(lcg()<0.03){ const gap = normal()*0.02; open = prevClose*(1+gap); if(open<=0) open=Math.abs(open)+1; }
        const close=S; const r=Math.abs(normal())*0.008; const baseMax=Math.max(open,close); const baseMin=Math.min(open,close); let high=baseMax + r*close; let low=baseMin - r*close; if(high<baseMax) high=baseMax; if(low>baseMin) low=baseMin; if(low<=0) low=Math.max(0.01,low);
        nextCandle = { time: (last.time||0)+1, open:round4(open), high:round4(high), low:round4(low), close:round4(close) };
        state.dataset.push(nextCandle);
        // Extender EMAs incrementalmente
        extendEMA(state.ema100, 100, nextCandle.close);
        extendEMA(state.ema50, 50, nextCandle.close);
        extendEMA(state.ema35, 35, nextCandle.close);
      }
      // Deslizar ventana: quitar la primera y añadir la nueva al final
      state.segmentStartIndex += 1;
      state.currentSegment = state.dataset.slice(state.segmentStartIndex, state.segmentStartIndex + SEGMENT_LENGTH);
      state.currentIndex = SEGMENT_LENGTH - 1; // última es la recién añadida en ventana
      updateChartProgress(); updateMetrics(); saveState(); // showToast('Avance 1 vela.', 'info');
    }

    function extendEMA(arr, period, newPrice){
      const alpha = 2 / (period + 1); const prev = arr[arr.length-1]; const next = (prev==null)? newPrice : (alpha*newPrice + (1-alpha)*prev); arr.push(next); }

    function nextScenario(){
      const lastPrice = getLastVisibleClose(); if(state.qty>0 && lastPrice!==null){ const qtyVendida=state.qty; const realizedAdd=qtyVendida*(lastPrice-(state.avgCost||0)); state.realized+=realizedAdd; state.cash+=qtyVendida*lastPrice; state.qty=0; state.avgCost=null; showToast(`Posición cerrada @ $${lastPrice.toFixed(2)} (qty=${qtyVendida}).`, 'success'); }
      const { segment, startIndex } = pickRandomSegment(state.dataset, SEGMENT_LENGTH); state.currentSegment=segment; state.segmentStartIndex=startIndex; state.currentIndex=SEGMENT_LENGTH-1; renderChart(state.currentSegment); updateMetrics(); saveState(); showToast('Nuevo escenario (ventana de 100).', 'info'); btnAdvance.disabled=false; }

    function getLastVisibleClose(){ if(!state.currentSegment.length) return null; const c=state.currentSegment[state.currentIndex]; return c? c.close : null; }

    function buy(qty){ if(!Number.isFinite(qty)||qty<=0||!Number.isInteger(qty)){ showToast('Cantidad inválida: entero > 0.', 'error'); return; } const price=getLastVisibleClose(); if(price===null){ showToast('No hay precio disponible.', 'error'); return; } const cost=qty*price; if(cost>state.cash+1e-9){ showToast('Fondos insuficientes.', 'error'); return; } const qtyAnt=state.qty; state.cash-=cost; state.qty+=qty; state.avgCost=(qtyAnt===0||state.avgCost==null)? price : ((state.avgCost*qtyAnt)+(price*qty))/(qtyAnt+qty); updateMetrics(); saveState(); showToast(`Compra: qty=${qty} @ $${price.toFixed(2)}.`, 'success'); }
    function sell(qty){ if(!Number.isFinite(qty)||!Number.isInteger(qty)||qty<=0){ showToast('Cantidad inválida para vender.', 'error'); return; } if(qty>state.qty){ showToast('No puedes vender más de lo que tienes.', 'error'); return; } const price=getLastVisibleClose(); if(price===null){ showToast('No hay precio disponible.', 'error'); return; } const realizedAdd=qty*(price-(state.avgCost||0)); state.realized+=realizedAdd; state.cash+=qty*price; state.qty-=qty; if(state.qty===0) state.avgCost=null; updateMetrics(); saveState(); showToast(`Venta: qty=${qty} @ $${price.toFixed(2)}.`, 'success'); }
    function sellAll(){ if(state.qty<=0){ showToast('No hay posición.', 'error'); return; } sell(state.qty); }

    function updateMetrics(){ const lastPrice=getLastVisibleClose(); const posVal=(state.qty>0&&lastPrice!==null)? state.qty*lastPrice : 0; const unrealized=(state.qty>0&&state.avgCost!=null&&lastPrice!==null)? state.qty*(lastPrice-state.avgCost) : 0; state.equity=(state.cash||0)+posVal; const gainPct=((state.equity-(state.capitalInicial||0))/(state.capitalInicial||1))*100; const positionPct=(state.equity>0)? (posVal/state.equity)*100 : 0; if(state.equity>(state.mejorEquity||0)) state.mejorEquity=state.equity; mInitial.textContent=formatUSD(state.capitalInicial); mCash.textContent=formatUSD(state.cash); mQty.textContent=String(state.qty); mAvg.textContent=(state.avgCost==null)? '—' : formatUSD(state.avgCost); mPosVal.textContent=formatUSD(posVal); mPosPct.textContent=formatPct(positionPct); mUnreal.textContent=formatUSD(unrealized); mRealized.textContent=formatUSD(state.realized); mEquity.textContent=formatUSD(state.equity); mGainPct.textContent=formatPct(gainPct); mScenarios.textContent=String(state.escenariosCompletados||0); mBestEquity.textContent=formatUSD(state.mejorEquity||0); mCandleIdx.textContent=`${Math.min(state.currentIndex+1, SEGMENT_LENGTH)} / ${SEGMENT_LENGTH}`; btnSell.disabled=(state.qty<=0); btnSellAll.disabled=(state.qty<=0); btnAdvance.disabled=false; }

    function saveState(){ try{ const payload={ capitalInicial:state.capitalInicial, cash:state.cash, qty:state.qty, avgCost:state.avgCost, realized:state.realized, equity:state.equity, mejorEquity:state.mejorEquity, escenariosCompletados:state.escenariosCompletados, params:state.params, dataset:state.dataset, ema100:state.ema100, ema50:state.ema50, ema35:state.ema35, segmentStartIndex:state.segmentStartIndex, currentSegment:state.currentSegment, currentIndex:state.currentIndex, lcgState:state.lcgState, normalSpare:state.normalSpare }; localStorage.setItem(LS_KEY, JSON.stringify(payload)); }catch(err){ console.error('Error guardando estado:', err); } }
    function loadState(){ try{ const raw=localStorage.getItem(LS_KEY); if(!raw) return false; const p=JSON.parse(raw); const keys=['capitalInicial','cash','qty','avgCost','realized','equity','mejorEquity','escenariosCompletados','params','dataset','ema100','ema50','ema35','segmentStartIndex','currentSegment','currentIndex','lcgState','normalSpare']; keys.forEach(k=>{ if(p[k]!==undefined) state[k]=p[k]; }); return true; }catch(err){ console.warn('No se pudo cargar estado previo:', err); return false; } }

    function resetState(){ const ok=confirm('Esto limpiará todo el estado y localStorage. ¿Continuar?'); if(!ok) return; localStorage.removeItem(LS_KEY); state.capitalInicial=CAPITAL_INICIAL_DEFAULT; state.cash=CAPITAL_INICIAL_DEFAULT; state.qty=0; state.avgCost=null; state.realized=0; state.equity=CAPITAL_INICIAL_DEFAULT; state.mejorEquity=CAPITAL_INICIAL_DEFAULT; state.escenariosCompletados=0; state.params={ total:DATA_TOTAL_DEFAULT, seed:Date.now()%1000000, mu:0.06, sigma:0.18 }; state.dataset=generateSyntheticData(state.params.total, state.params.seed, state.params.mu, state.params.sigma); state.ema100=computeEMA(state.dataset,100); state.ema50=computeEMA(state.dataset,50); state.ema35=computeEMA(state.dataset,35); const {segment,startIndex}=pickRandomSegment(state.dataset,SEGMENT_LENGTH); state.currentSegment=segment; state.segmentStartIndex=startIndex; state.currentIndex=SEGMENT_LENGTH-1; renderChart(state.currentSegment); updateMetrics(); elSeed.value=String(state.params.seed); elMu.value=String(state.params.mu); elSigma.value=String(state.params.sigma); btnAdvance.disabled=false; showToast('Estado reseteado.', 'success'); }

    function setupKeyboardShortcuts(){ window.addEventListener('keydown',(ev)=>{ const k=ev.key.toLowerCase(); if(['b','s','x','a','n'].includes(k)) ev.preventDefault(); switch(k){ case 'b':{ const q=parseInt(elQty.value,10); if(!isNaN(q)) buy(q); else showToast('Ingresa una cantidad entera.', 'error'); break; } case 's':{ const q=parseInt(elQty.value,10); if(!isNaN(q)) sell(q); else showToast('Ingresa una cantidad entera.', 'error'); break; } case 'x': sellAll(); break; case 'a': advanceOneCandle(); break; case 'n': nextScenario(); break; } }); }

    function showToast(message,type='info'){ const div=document.createElement('div'); div.className=`toast ${type}`; div.textContent=message; elToasts.appendChild(div); setTimeout(()=>{ div.style.opacity='0'; div.style.transition='opacity 250ms ease'; setTimeout(()=>div.remove(),300); },2000); }

    function bindEvents(){ btnNewData.addEventListener('click',()=>{ const seed=parseInt(elSeed.value,10); const mu=parseFloat(elMu.value); const sigma=parseFloat(elSigma.value); state.params.seed=Number.isFinite(seed)?seed:(Date.now()%1000000); state.params.mu=Number.isFinite(mu)?mu:0.06; state.params.sigma=Number.isFinite(sigma)?sigma:0.18; state.dataset=generateSyntheticData(state.params.total, state.params.seed, state.params.mu, state.params.sigma); state.ema100=computeEMA(state.dataset,100); state.ema50=computeEMA(state.dataset,50); state.ema35=computeEMA(state.dataset,35); const {segment,startIndex}=pickRandomSegment(state.dataset,SEGMENT_LENGTH); state.currentSegment=segment; state.segmentStartIndex=startIndex; state.currentIndex=SEGMENT_LENGTH-1; renderChart(state.currentSegment); updateMetrics(); saveState(); btnAdvance.disabled=false; showToast('Nuevo dataset (100 velas visibles). Usa Advance para seguir.', 'success'); }); btnBuy.addEventListener('click',()=>{ const q=parseInt(elQty.value,10); if(isNaN(q)){ showToast('Ingresa una cantidad entera.', 'error'); return; } buy(q); }); btnSell.addEventListener('click',()=>{ const q=parseInt(elQty.value,10); if(isNaN(q)){ showToast('Ingresa una cantidad entera.', 'error'); return; } sell(q); }); btnSellAll.addEventListener('click',()=>sellAll()); btnAdvance.addEventListener('click',()=>advanceOneCandle()); btnNext.addEventListener('click',()=>nextScenario()); btnReset.addEventListener('click',()=>resetState()); window.addEventListener('resize',()=>{ resizeCanvas(); drawChart(); }); }

    function init(){ const has=loadState(); if(!has){ state.dataset=generateSyntheticData(state.params.total, state.params.seed, state.params.mu, state.params.sigma); state.ema100=computeEMA(state.dataset,100); state.ema50=computeEMA(state.dataset,50); state.ema35=computeEMA(state.dataset,35); const {segment,startIndex}=pickRandomSegment(state.dataset,SEGMENT_LENGTH); state.currentSegment=segment; state.segmentStartIndex=startIndex; state.currentIndex=SEGMENT_LENGTH-1; } resizeCanvas(); renderChart(state.currentSegment); updateMetrics(); elSeed.value=String(state.params.seed); elMu.value=String(state.params.mu); elSigma.value=String(state.params.sigma); if(!elQty.value) elQty.value='100'; bindEvents(); setupKeyboardShortcuts(); showToast('Atajos: B, S, X, A, N. Usa Advance para avanzar la ventana.', 'info'); }

    init();
  </script>
</body>
</html>
